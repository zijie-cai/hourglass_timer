<!DOCTYPE html>
<html>
<head>
    <title>Enhanced Pixelated Digital Hourglass Visualization</title>
    <style>
        body {
            margin: 0;
            background: linear-gradient(to bottom, #1e3c72, #2a5298); /* Background gradient */
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        canvas {
            border: 1px solid #555;
            image-rendering: pixelated;
        }
    </style>
</head>
<body>
    <!-- The canvas will be inserted by the script -->
    <script>
        // Create the pixelated hourglass visualization
        var createPixelGlass = function(){
            // Numerical codes representing different cell types
            var pixelCodes = {
                background: 0,
                interior: 1,
                walls: 2,
                walls2: 3,
                base: 4,
                base2: 5,
                base3: 6,
                stopper: 7,
                sand1: 8,
                sand2: 9,
                sand3: 10,
                dummySand: 11, // Dummy sand not really simulated, visual effect only
            };

            var defaultConfig = {
                pixelSize: 3,        // Adjusted pixel size for better visibility
                width: 99,           // Total cells wide
                height: 150,         // Total cells high (increased height for a taller hourglass)
                offsetX: 0,          // X Offset entire cell grid within canvas 
                offsetY: 0,          // Y Offset entire cell grid within canvas
                cylinderHeight: 20,  // Adjusted to make the middle gap smaller and shape more elegant
                timeStep: 30,        // Smaller number gives smoother animation but worse performance
                touchRadius: 4,      // Size of area affected by mouse/touch
                interactive: true,   // Whether or not the mouse/touch will affect sand
                transparentBackground: true,
                pixelColors : {
                    0: "rgba(0,0,0,0)",  // Transparent background
                    1: "rgba(255,255,255,0.1)", // Interior
                    2: "rgba(200,200,255,0.3)", // Hourglass walls (light blue with transparency)
                    3: "rgba(200,200,255,0.4)", // Hourglass walls 2
                    4: "#8B4513",        // Base (saddle brown)
                    5: "#A0522D",        // Base 2 (sienna)
                    6: "#CD853F",        // Base 3 (peru)
                    7: "#D3D3D3",        // Stopper (light gray)
                    8: "#F0E68C",        // Sand 1 (khaki)
                    9: "#EEE8AA",        // Sand 2 (pale goldenrod)
                    10:"#FAFAD2",        // Sand 3 (light goldenrod yellow)
                    11:"#F5DEB3",        // Dummy sand (wheat)
                }
            };

            // Make mousePosition accessible throughout the script
            var mousePosition = { x: 0, y: 0 };

            var HourGlass = function(config){
                this.config = config || defaultConfig;
                this.tiles = [];
                this.canvas = document.createElement('canvas');
                this.canvas.width = this.config.width * this.config.pixelSize;
                this.canvas.height = this.config.height * this.config.pixelSize;
                this.grainsTotal = 0;
                this.grainsDropped = 0;
                this.time = 0;
                this.running = false;
                this.grainDropDelay = 0;
                this.leftToRight = false;
                this.create();

                // Add mouse event listener if interactive
                if (this.config.interactive) {
                    var me = this;
                    this.canvas.addEventListener('mousemove', function(event){
                        var rect = me.canvas.getBoundingClientRect();
                        var scaleX = me.config.width / rect.width;
                        var scaleY = me.config.height / rect.height;
                        mousePosition.x = (event.clientX - rect.left) * scaleX;
                        mousePosition.y = (event.clientY - rect.top) * scaleY;
                    });
                }
            };

            HourGlass.prototype.create = function(){
                this.running = false;

                // Build top and bottom halves of the hourglass
                var topHalf = [],
                    bottomHalf = [],
                    w = this.config.width,
                    h = this.config.height,
                    z = this.config.cylinderHeight;

                for (var y = 0; y < h / 2; y++) {
                    var topRow = [],
                        bottomRow = [];
                    for (var x = 0; x < w; x++) {

                        // Hourglass base
                        if ((y >= 0 && y <= 2) && (x > z - 3 && x < w - z + 2)) {
                            var c = pixelCodes.base;
                            if (y == 1) c = pixelCodes.base2;
                            else if (y == 2) c = pixelCodes.base3;
                            topRow.push(c);
                            bottomRow.push(c);
                        }

                        // Hourglass walls
                        else if (x == z || x == z + 1 || x == (w - z - 1) || x == (w - z - 2)) {
                            // Magic number determines where middle ring lies
                            var ringRatio = 1.2; // Adjusted for shape refinement
                            var c = y >= (this.config.cylinderHeight * ringRatio) ? pixelCodes.walls2 : pixelCodes.walls;
                            topRow.push(c);
                            bottomRow.push(c);
                        }

                        // Interior & sand
                        else if (x > z && x < (w - z - 1)) {
                            if (Math.random() < 0.33) topRow.push(pixelCodes.sand1);
                            else if (Math.random() < 0.66) topRow.push(pixelCodes.sand2);
                            else topRow.push(pixelCodes.sand3);
                            this.grainsTotal++; // Count the sand
                            bottomRow.push(pixelCodes.interior);
                        }

                        // Exterior / background
                        else {
                            topRow.push(pixelCodes.background);
                            bottomRow.push(pixelCodes.background);
                        }
                    }

                    // Add rows to top/bottom arrays
                    if (z < w / 2 - 5 && y > this.config.cylinderHeight) z++;
                    topHalf.push(topRow);
                    bottomHalf.push(bottomRow);
                }

                // Reverse bottom and append to top
                this.tiles = topHalf.concat(bottomHalf.reverse());

                // Remove a single grain from the top to prevent an extra grain
                this.tiles[Math.floor(h / 2 - 1)][Math.floor(w / 2)] = pixelCodes.interior;
                this.grainsTotal--;

                // Create Stopper (the grain dropper)
                this.tiles[Math.floor(h / 2)][Math.floor(w / 2)] = pixelCodes.stopper;
                this.render();
            };

            HourGlass.prototype.render = function(){
                var context = this.canvas.getContext("2d"),
                    w = this.config.width,
                    h = this.config.height,
                    s = this.config.pixelSize,
                    cw = this.canvas.width,
                    ch = this.canvas.height;  

                // Clear canvas for next frame
                context.clearRect(0, 0, cw, ch);

                // Draw cells
                for (var y = 0; y < h; y++) {
                    for (var x = 0; x < w; x++) {
                        var cell = this.tiles[y][x];
                        // Ignore background tiles
                        if (cell != pixelCodes.background) {
                            // Apply gradient to sand
                            if (cell >= pixelCodes.sand1 && cell <= pixelCodes.sand3) {
                                var gradient = context.createLinearGradient(
                                    (x + this.config.offsetX) * s,
                                    (y + this.config.offsetY) * s,
                                    (x + this.config.offsetX) * s,
                                    (y + this.config.offsetY + 1) * s
                                );
                                gradient.addColorStop(0, this.config.pixelColors[cell]);
                                gradient.addColorStop(1, "#DAA520"); // Goldenrod at the bottom
                                context.fillStyle = gradient;
                            } else {
                                context.fillStyle = this.config.pixelColors[cell];
                            }

                            context.fillRect(
                                (x + this.config.offsetX) * s,
                                (y + this.config.offsetY) * s,
                                s,
                                s
                            );
                        }
                    }
                }
            };

            HourGlass.prototype.update = function(state){
                // Keep track of the time that has passed between frames
                var now = Date.now(),
                    updated = false,
                    dt = this.config.timeStep;

                state.timeAcc += now - state.lastFrame;
                state.lastFrame = now;

                while (state.timeAcc >= dt){
                    updated = true;
                    state.timeAcc -= dt;
                    state.grainTimeAcc += dt;
                    if (state.grainTimeAcc >= this.grainDropDelay) {
                        this.updateDelay(this.time - (Date.now() - state.startTime));
                        state.grainTimeAcc = 0;
                        this.dropGrain();
                    } 
                    else if (Math.random() > 0.8) {
                        this.dropDummyGrain();
                    }

                    // Alternate update direction to prevent bias
                    var w = this.config.width,
                        h = this.config.height,
                        lr = this.leftToRight;
                    for (var x = (lr ? w - 1 : 0); (lr ? x > -1 : x < w); (lr ? x-- : x++)) {
                        for (var y = h - 1; y > -1; y--) {
                            this.updateCell(x, y);
                        }
                    }
                    this.leftToRight = !this.leftToRight;
                }
                return updated;
            };

            HourGlass.prototype.updateCell = function(x, y){
                // Only sand cells get updated
                if (this.tiles[y][x] < pixelCodes.sand1) return;
                var interior = pixelCodes.interior;
                // Inspect neighbours
                var blockedBottom = this.tiles[y + 1][x] > interior,
                    blockedTop = this.tiles[y - 1][x] > interior,
                    blockedRight = this.tiles[y][x + 1] > interior,
                    blockedLeft = this.tiles[y][x - 1] > interior,
                    blockedBottomLeft = this.tiles[y + 1][x - 1] > interior,
                    blockedBottomRight = this.tiles[y + 1][x + 1] > interior;

                // Handle mouse interaction with sand
                if (this.config.interactive) {
                    var mouseSize = this.config.touchRadius,
                        dx = this.config.offsetX,
                        dy = this.config.offsetY,
                        mx = mousePosition.x,
                        my = mousePosition.y;

                    if (
                        x > mx - mouseSize - dx && x < mx + mouseSize - dx &&
                        y < my + mouseSize / 2 - dy && y > my - mouseSize / 2 - dy
                    ) {
                        blockedBottom = true;
                        blockedBottomLeft = true;
                        blockedBottomRight = true;
                    }
                }

                // Remove dummy sand from simulation
                if (
                    this.tiles[y][x] == pixelCodes.dummySand &&
                    blockedBottom && blockedTop && blockedLeft && blockedRight
                ) {
                    this.tiles[y][x] = interior;
                    return;
                }

                // Adjust when a grain of sand will move laterally
                var n = 1,
                    r = Math.floor(Math.random() * (this.config.cylinderHeight * n)),
                    w = this.config.width,
                    h = this.config.height;

                // Movement rules
                if (!blockedBottom) this.moveCell(x, y, 0, 1); // Down
                else if (!blockedBottomLeft) this.moveCell(x, y, -1, 1); // Down & left
                else if (!blockedBottomRight) this.moveCell(x, y, 1, 1); // Down & right
                else if (x < Math.floor(w / 2) - r && !blockedRight && y < Math.floor(h / 2)) this.moveCell(x, y, 1, 0); // Move right
                else if (x > Math.floor(w / 2) + r && !blockedLeft && y < Math.floor(h / 2)) this.moveCell(x, y, -1, 0); // Move left  
                else if (x < Math.floor(w / 2) - r * 3 && !blockedLeft && blockedRight && y > Math.floor(h / 2)) this.moveCell(x, y, -1, 0); // Move left
                else if (x > Math.floor(w / 2) + r * 3 && !blockedRight && blockedLeft && y > Math.floor(h / 2)) this.moveCell(x, y, 1, 0); // Move right
            };

            HourGlass.prototype.dropGrain = function(){
                // The stopper acts like a wall
                var stoppery = Math.floor(this.config.height / 2),
                    stopperx = Math.floor(this.config.width / 2),
                    tileAbove = this.tiles[stoppery - 1][stopperx],
                    tileBelow = this.tiles[stoppery + 1][stopperx];

                if (
                    (tileBelow == pixelCodes.interior || tileBelow == pixelCodes.dummySand) &&
                    (tileAbove >= pixelCodes.sand1)
                ) {
                    this.grainsDropped++;
                    this.moveCell(stopperx, stoppery - 1, 0, 2);
                }
            };

            HourGlass.prototype.dropDummyGrain = function(){
                var stoppery = Math.floor(this.config.height / 2),
                    stopperx = Math.floor(this.config.width / 2);
                if (this.tiles[stoppery + 1][stopperx] == pixelCodes.interior) {
                    this.tiles[stoppery + 1][stopperx] = pixelCodes.dummySand;
                }
            };

            HourGlass.prototype.updateDelay = function(t){
                this.grainDropDelay = Math.floor(t / (this.grainsTotal - this.grainsDropped));
            };

            HourGlass.prototype.moveCell = function(x, y, x1, y1) {
                var tmp = this.tiles[y + y1][x + x1];
                this.tiles[y + y1][x + x1] = this.tiles[y][x];
                this.tiles[y][x] = tmp;
            };

            HourGlass.prototype.start = function(mins, callback){
                var now = Date.now();
                this.time = mins * 60000;
                this.updateDelay(this.time);
                this.running = true;
                var state = {
                    startTime: now,
                    lastFrame: now,
                    timeAcc: 0,
                    grainTimeAcc: 0
                };
                var me = this;
                var loop = function(){
                    if (me.running && me.update(state)) me.render();
                    if (me.grainsDropped >= me.grainsTotal) {
                        me.running = false;
                        if (callback) callback();
                    }
                    else if (me.running === true) {
                        requestAnimationFrame(loop);
                    }
                };
                loop();
            };

            HourGlass.prototype.setSandHue = function(hue){
                this.config.pixelColors[pixelCodes.sand1] = "hsl(" + hue + ",70%,60%)";
                this.config.pixelColors[pixelCodes.sand2] = "hsl(" + hue + ",65%,50%)";
                this.config.pixelColors[pixelCodes.sand3] = "hsl(" + hue + ",80%,65%)";
                this.render();
            };

            var HourGlassController = function(hourglass){
                this.hourglass = hourglass;
            };
            HourGlassController.prototype.start = function(time, callback){
                this.hourglass.start(time, callback);
            };
            HourGlassController.prototype.reset = function(){
                this.hourglass.create();
            };
            HourGlassController.prototype.getCanvas = function(){
                return this.hourglass.canvas;
            };
            HourGlassController.prototype.setHue = function(hue){
                this.hourglass.setSandHue(hue);
            };

            return new HourGlassController(new HourGlass());
        };

        // Initialize the hourglass
        var hourglass = createPixelGlass();

        // Append the canvas to the body
        document.body.appendChild(hourglass.getCanvas());

        // Start the hourglass (duration in minutes)
        hourglass.start(1); // Runs for 1 minute

        // Optional: Change the sand hue
        // hourglass.setHue(30); // Hue value between 0 and 360

    </script>
</body>
</html>
