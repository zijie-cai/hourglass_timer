<!DOCTYPE html>
<html>
<head>
    <title>Water Flow Hourglass Simulation</title>
    <style>
        body {
            margin: 0;
            background-color: #222;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        canvas {
            border: 1px solid #555;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
        }

        #controls button {
            margin-right: 5px;
        }

        #controls input[type=range] {
            width: 100px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button id="startButton">Start</button>
        <button id="resetButton">Reset</button>
        <label for="hueRange">Sand Hue:</label>
        <input type="range" id="hueRange" min="0" max="360" value="55">
    </div>
    <canvas id="hourglassCanvas"></canvas>
    <script>
        // Get canvas and context
        const canvas = document.getElementById('hourglassCanvas');
        const ctx = canvas.getContext('2d');

        // Set canvas dimensions
        canvas.width = 400;
        canvas.height = 600;

        // Particle properties
        const particles = [];
        let numParticles = 500;
        const gravity = 0.1;
        let sandHue = 55;

        // Timer properties
        let totalTime = 60000; // default 1 minute
        let startTime = null;
        let running = false;

        // Hourglass dimensions
        const hourglassWidthTop = 300;
        const hourglassWidthBottom = 300;
        const hourglassHeight = 500;
        const hourglassX = canvas.width / 2;
        const hourglassY = canvas.height / 2;
        const neckWidth = 10;
        const neckPosition = canvas.height / 2;

        // Controls
        const startButton = document.getElementById('startButton');
        const resetButton = document.getElementById('resetButton');
        const hueRange = document.getElementById('hueRange');

        // Initialize particles in the upper chamber
        function initializeParticles() {
            particles.length = 0;
            for (let i = 0; i < numParticles; i++) {
                particles.push({
                    x: hourglassX + (Math.random() - 0.5) * (hourglassWidthTop - 20),
                    y: hourglassY - hourglassHeight / 2 + Math.random() * (hourglassHeight / 2 - 20),
                    vx: 0,
                    vy: 0,
                    radius: 3,
                    color: `hsl(${sandHue}, 70%, 60%)`,
                    inUpperChamber: true,
                });
            }
        }

        // Update particles
        function updateParticles(deltaTime) {
            for (let particle of particles) {
                // Apply gravity
                particle.vy += gravity;

                // Update position
                particle.x += particle.vx;
                particle.y += particle.vy;

                // Collision detection with hourglass walls
                // Upper chamber
                if (particle.y < neckPosition && particle.inUpperChamber) {
                    const chamberHeight = neckPosition - (hourglassY - hourglassHeight / 2);
                    const progress = (particle.y - (hourglassY - hourglassHeight / 2)) / chamberHeight;
                    const chamberWidth = hourglassWidthTop / 2 - (hourglassWidthTop / 2 - neckWidth / 2) * progress;
                    const leftWall = hourglassX - chamberWidth;
                    const rightWall = hourglassX + chamberWidth;

                    if (particle.x - particle.radius < leftWall) {
                        particle.x = leftWall + particle.radius;
                        particle.vx *= -0.5;
                    } else if (particle.x + particle.radius > rightWall) {
                        particle.x = rightWall - particle.radius;
                        particle.vx *= -0.5;
                    }

                    // Check if particle can pass through neck
                    if (particle.y + particle.radius >= neckPosition) {
                        // Check for blockage (simulate particles stacking at the neck)
                        const neckParticles = particles.filter(p => Math.abs(p.x - hourglassX) < neckWidth / 2 && p.y >= neckPosition && p.y <= neckPosition + 5);
                        if (neckParticles.length < 5) {
                            // Allow particle to pass
                            particle.inUpperChamber = false;
                        } else {
                            // Block particle
                            particle.y = neckPosition - particle.radius;
                            particle.vy = 0;
                        }
                    }
                }
                // Lower chamber
                else {
                    const chamberHeight = (hourglassY + hourglassHeight / 2) - neckPosition;
                    const progress = (particle.y - neckPosition) / chamberHeight;
                    const chamberWidth = neckWidth / 2 + (hourglassWidthBottom / 2 - neckWidth / 2) * progress;
                    const leftWall = hourglassX - chamberWidth;
                    const rightWall = hourglassX + chamberWidth;

                    if (particle.x - particle.radius < leftWall) {
                        particle.x = leftWall + particle.radius;
                        particle.vx *= -0.5;
                    } else if (particle.x + particle.radius > rightWall) {
                        particle.x = rightWall - particle.radius;
                        particle.vx *= -0.5;
                    }

                    // Bottom collision
                    if (particle.y + particle.radius > hourglassY + hourglassHeight / 2) {
                        particle.y = hourglassY + hourglassHeight / 2 - particle.radius;
                        particle.vy *= -0.5;
                        particle.vx *= 0.5; // Friction
                    }
                }

                // Optional: Add slight horizontal movement
                particle.vx += (Math.random() - 0.5) * 0.02;

                // Interactivity: Mouse interaction
                if (mouse.isDown) {
                    const dx = particle.x - mouse.x;
                    const dy = particle.y - mouse.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 50) {
                        const angle = Math.atan2(dy, dx);
                        const force = (50 - dist) / 50;
                        particle.vx += Math.cos(angle) * force * 0.5;
                        particle.vy += Math.sin(angle) * force * 0.5;
                    }
                }
            }
        }

        // Draw everything
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw hourglass outline
            ctx.strokeStyle = '#6acfdd';
            ctx.lineWidth = 5;
            ctx.beginPath();

            // Left side upper chamber
            ctx.moveTo(hourglassX - hourglassWidthTop / 2, hourglassY - hourglassHeight / 2);
            ctx.lineTo(hourglassX - neckWidth / 2, neckPosition);

            // Left side lower chamber
            ctx.lineTo(hourglassX - hourglassWidthBottom / 2, hourglassY + hourglassHeight / 2);

            // Right side lower chamber
            ctx.moveTo(hourglassX + hourglassWidthBottom / 2, hourglassY + hourglassHeight / 2);
            ctx.lineTo(hourglassX + neckWidth / 2, neckPosition);

            // Right side upper chamber
            ctx.lineTo(hourglassX + hourglassWidthTop / 2, hourglassY - hourglassHeight / 2);

            ctx.stroke();

            // Draw particles
            for (let particle of particles) {
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        let lastTime = 0;
        function animate(timestamp) {
            if (!lastTime) lastTime = timestamp;
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            if (running) {
                updateParticles(deltaTime);
                // Check timer
                const elapsedTime = timestamp - startTime;
                if (elapsedTime >= totalTime) {
                    running = false;
                }
            }
            draw();
            requestAnimationFrame(animate);
        }

        // Mouse interaction
        const mouse = {
            x: 0,
            y: 0,
            isDown: false,
        };
        canvas.addEventListener('mousedown', function (e) {
            mouse.isDown = true;
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        });
        canvas.addEventListener('mouseup', function () {
            mouse.isDown = false;
        });
        canvas.addEventListener('mousemove', function (e) {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        });

        // Start button event
        startButton.addEventListener('click', function () {
            if (!running) {
                startTime = performance.now();
                running = true;
            }
        });

        // Reset button event
        resetButton.addEventListener('click', function () {
            running = false;
            initializeParticles();
            draw();
        });

        // Hue range event
        hueRange.addEventListener('input', function () {
            sandHue = hueRange.value;
            for (let particle of particles) {
                particle.color = `hsl(${sandHue}, 70%, 60%)`;
            }
            draw();
        });

        // Initialize
        initializeParticles();
        draw();
        requestAnimationFrame(animate);

    </script>
</body>
</html>
